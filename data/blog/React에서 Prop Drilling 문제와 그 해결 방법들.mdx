---
title: React에서 Prop Drilling 문제와 그 해결 방법들
date: '2024-02-12'
tags: [props]
draft: false
summary: 'Prop Drilling'
---

# React에서 Prop Drilling 문제와 그 해결 방법들

React에서 효율적인 상태 관리를 위해 컴포넌트 계층이 깊어질 때 발생하는 Prop Drilling 문제를 설명하고, 이를 해결하기 위한 방법들(Context API, useReducer, 상태 관리 라이브러리 등)과 각각의 장단점을 설명하세요.

​

질문의도 입니다!

​

Prop Drilling 문제를 이해하고, 이를 해결하기 위한 다양한 상태 관리 전략(Context API, useReducer, Redux 등)을 알고 있는지를 평가합니다. 각 방법의 장단점을 비교하여 설명하고, 실무에서 상황에 맞는 적절한 상태 관리 방법을 선택할 수 있는 능력을 확인합니다.

---

**모범답안**

**Prop Drilling 문제란?**

React에서 컴포넌트 계층이 깊어질 때, 상위 컴포넌트의 상태를 하위 컴포넌트로 전달하기 위해 props를 통해 전달하는 과정을 "Prop Drilling"이라고 합니다. 이 문제는 하위 컴포넌트들이 실제로는 필요하지 않은 props를 단지 전달하기 위해서 받아야 하는 경우에 발생합니다. 이는 코드의 유지보수성을 떨어뜨리고, 컴포넌트 간 결합도를 높이며, 코드의 가독성을 저하시킬 수 있습니다.

**Prop Drilling 문제를 해결하는 방법**

1. **Context API**
   - **개념**: React의 내장 기능인 Context API는 상태를 전역으로 관리할 수 있는 기능을 제공합니다. Context를 사용하면 부모-자식 간의 props 전달 없이 전역적으로 데이터를 제공할 수 있습니다.
   - **장점**: 간단한 상태를 전역으로 관리하기에 좋고, 별도의 라이브러리 설치가 필요 없습니다. 기본적인 전역 상태 관리에 적합하며 사용법도 비교적 직관적입니다.
   - **단점**: 상태가 복잡해질 경우 코드가 복잡해질 수 있고, 성능 최적화를 위해서는 `React.memo`나 `useMemo`, `useCallback`을 추가적으로 사용해야 합니다. Context의 값이 변경되면 해당 Context를 사용하는 모든 컴포넌트가 재렌더링될 수 있기 때문에 성능 문제가 발생할 수 있습니다.
2. **useReducer와 Context API의 조합**
   - **개념**: `useReducer`는 복잡한 상태 변경 로직을 작성할 때 사용하는 React Hook으로, Context와 함께 사용하면 Redux와 비슷한 전역 상태 관리 기능을 제공합니다. Context는 상태를 전역으로 제공하고, `useReducer`는 복잡한 상태 업데이트 로직을 구현하는 데 사용됩니다.
   - **장점**: 상태 업데이트 로직을 하나의 리듀서 함수로 관리할 수 있어 유지보수성이 높아지고, 복잡한 상태 관리에 적합합니다. React의 내장 기능만으로 상태 관리를 할 수 있어 라이브러리 의존성을 줄일 수 있습니다.
   - **단점**: 상태와 로직이 복잡해지면 코드가 장황해질 수 있으며, 대규모 애플리케이션에서는 상태 관리를 제대로 최적화하지 않으면 성능 문제를 유발할 수 있습니다.
3. **상태 관리 라이브러리 (Redux, Zustand 등)**
   - **Redux**
     - **개념**: Redux는 전역 상태 관리를 위해 가장 널리 사용되는 라이브러리 중 하나로, 전역 상태를 한 곳에서 관리하며 상태를 예측 가능한 방식으로 업데이트합니다.
     - **장점**: 전역 상태를 명확하게 정의하고 상태 변경 로직을 철저하게 분리하여 코드의 예측 가능성과 유지보수성을 높입니다. 또한 Redux DevTools를 통해 상태 변경을 추적할 수 있어 디버깅이 용이합니다.
     - **단점**: 보일러플레이트 코드가 많아 학습 곡선이 높으며, 설정 과정이 다소 복잡할 수 있습니다. 단순한 애플리케이션에는 불필요하게 무거운 선택일 수 있습니다.
   - **Zustand**
     - **개념**: Zustand는 가볍고 사용이 간편한 상태 관리 라이브러리로, 전역 상태를 관리할 수 있도록 도와줍니다.
     - **장점**: 간단하고 직관적인 API를 제공하며, 보일러플레이트 코드가 적습니다. 또한, React의 컴포넌트 구조에 크게 의존하지 않아 독립적인 사용이 가능하고 성능 최적화가 용이합니다.
     - **단점**: Redux만큼 큰 커뮤니티나 확장 가능한 미들웨어를 제공하지 않아, 매우 복잡한 상태 관리에는 상대적으로 한계가 있을 수 있습니다.

**실무에서의 선택 기준**

- **간단한 전역 상태**: 로그인 상태, 사용자 정보 등 간단한 전역 상태는 **Context API**로 관리할 수 있습니다.
- **복잡한 상태 로직**: 복잡한 상태 업데이트가 필요하다면 **useReducer와 Context API의 조합**을 고려해볼 수 있습니다.
- **대규모 애플리케이션**: 전역 상태가 많고 복잡한 애플리케이션이라면 **Redux**와 같은 상태 관리 라이브러리를 사용하는 것이 적합합니다. Redux DevTools를 통해 디버깅과 상태 추적이 용이합니다.
- **간단하고 효율적인 상태 관리**: 코드가 간결하고 보일러플레이트가 적은 상태 관리 라이브러리를 원한다면 **Zustand**를 사용하는 것이 좋습니다.

---

React 개발을 하다 보면 컴포넌트 구조가 깊어지면서 "Prop Drilling"이라는 문제가 발생할 수 있습니다. Prop Drilling이란 상위 컴포넌트의 상태를 하위 컴포넌트까지 props로 전달하는 과정에서 발생하는 문제로, 불필요하게 많은 컴포넌트들이 props를 단지 전달하기 위해 받아야 하는 상황을 말합니다. 이는 코드의 유지보수성을 떨어뜨리고, 컴포넌트 간 결합도를 높이며, 코드의 가독성을 저하시킬 수 있습니다.

이번 글에서는 이러한 Prop Drilling 문제를 해결할 수 있는 다양한 방법들을 알아보고, 각 방법의 장단점을 비교해보도록 하겠습니다.

### **Prop Drilling 문제를 해결하는 방법**

1. **Context API**

   **Context API**는 React에서 기본적으로 제공하는 상태 관리 도구로, 전역적으로 데이터를 관리할 수 있는 기능을 제공합니다. 이를 통해 props를 통해 데이터를 전달하지 않아도, 여러 컴포넌트에서 데이터를 쉽게 공유할 수 있습니다.

   - **장점**: 간단한 상태를 전역으로 관리하기 좋으며, 별도의 라이브러리 설치가 필요 없습니다. 사용법이 직관적이라서 간단한 전역 상태 관리에 유용합니다.
   - **단점**: 상태가 복잡해질 경우 코드가 복잡해질 수 있으며, 성능 최적화를 위해 추가적인 최적화 기법이 필요합니다. Context의 값이 변경될 때 해당 값을 사용하는 모든 컴포넌트가 다시 렌더링되는 문제가 발생할 수 있습니다.

2. **useReducer와 Context API의 조합**

   **useReducer**는 복잡한 상태 변경 로직을 다루기에 적합한 React Hook입니다. `useReducer`를 Context API와 함께 사용하면 전역 상태 관리 기능을 더욱 강력하게 만들 수 있습니다. Context는 상태를 전역적으로 제공하고, `useReducer`는 상태 업데이트 로직을 간결하고 명확하게 관리하는 데 도움을 줍니다.

   - **장점**: 상태 업데이트 로직을 하나의 리듀서 함수로 관리하여 유지보수성이 높아지며, 복잡한 상태 관리에 적합합니다. 별도의 라이브러리 없이 상태 관리가 가능하여 의존성을 줄일 수 있습니다.
   - **단점**: 코드가 장황해질 수 있으며, 대규모 애플리케이션에서는 성능 문제를 유발할 수 있습니다. 또한 상태와 로직이 복잡해질 경우 가독성이 떨어질 수 있습니다.

3. **상태 관리 라이브러리 (Redux, Zustand 등)**

   - **Redux**

     **Redux**는 전역 상태 관리를 위해 가장 널리 사용되는 라이브러리 중 하나로, 상태를 예측 가능하게 관리하고 상태 변경을 중앙에서 통제할 수 있게 해줍니다.

     - **장점**: 상태를 명확하게 정의하고 변경 로직을 분리하여 코드의 예측 가능성을 높여줍니다. 또한 Redux DevTools를 이용해 상태 변경을 추적할 수 있어 디버깅이 용이합니다.
     - **단점**: 보일러플레이트 코드가 많아 학습 곡선이 높고, 설정 과정이 복잡할 수 있습니다. 단순한 애플리케이션에는 불필요하게 무겁습니다.

   - **Zustand**

     **Zustand**는 비교적 가벼운 상태 관리 라이브러리로, 간단한 전역 상태 관리를 위해 유용합니다.

     - **장점**: 사용이 간편하고 API가 직관적이며, 보일러플레이트 코드가 적습니다. React의 컴포넌트 구조에 크게 의존하지 않아 독립적으로 사용이 가능하며, 성능 최적화가 용이합니다.
     - **단점**: Redux만큼 큰 커뮤니티나 확장 가능한 미들웨어를 제공하지 않아, 복잡한 상태 관리에는 다소 한계가 있을 수 있습니다.

### **실무에서의 상태 관리 선택 기준**

- **간단한 전역 상태**: 로그인 상태나 사용자 정보와 같은 간단한 전역 상태는 **Context API**를 사용하여 관리할 수 있습니다.
- **복잡한 상태 로직**: 상태 업데이트 로직이 복잡하고 다루기 어려운 경우 **useReducer와 Context API의 조합**을 사용하는 것이 좋습니다.
- **대규모 애플리케이션**: 전역 상태가 많고 복잡한 애플리케이션의 경우 **Redux**와 같은 강력한 상태 관리 라이브러리를 사용하는 것이 적합합니다. 특히, Redux DevTools를 통해 상태를 쉽게 추적하고 디버깅할 수 있는 점이 큰 장점입니다.
- **간단하고 효율적인 상태 관리**: 보일러플레이트가 적고 코드가 간결해야 하는 경우 **Zustand**와 같은 가벼운 상태 관리 라이브러리가 적합합니다.

### **결론**

Prop Drilling 문제는 컴포넌트 계층이 깊어질수록 코드의 유지보수성과 가독성을 떨어뜨리는 주요 원인이 될 수 있습니다. 이를 해결하기 위해 Context API, useReducer, 그리고 다양한 상태 관리 라이브러리를 사용할 수 있으며, 각 도구의 장단점을 이해하고 적절한 상황에서 활용하는 것이 중요합니다. 프로젝트의 규모와 복잡성, 요구사항에 따라 적합한 상태 관리 방법을 선택하여 개발 효율성과 유지보수성을 극대화할 수 있습니다.
