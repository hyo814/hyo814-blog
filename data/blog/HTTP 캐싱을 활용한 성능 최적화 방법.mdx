---
title: HTTP 캐싱 - HTTP 캐싱을 활용한 성능 최적화 방법
date: '2024-09-21'
tags: [HTTP]
draft: false
summary: 'HTTP 캐싱'
---

# HTTP 캐싱을 활용한 성능 최적화 방법

HTTP 헤더 중 캐싱 관련 헤더(Cache-Control, ETag, Expires 등)의 역할을 설명하, 브라우저에서 캐싱을 효과적으로 활용하여 성능을 최적화하는 방법에 대해 설명하세요. 또한 캐싱 설정 시 발생할 수 있는 문제와 이를 해결하기 위한 방안에 대해 설명해주세요.

​

질문의도 입니다!

​

HTTP 헤더를 통해 웹 애플리케이션의 성능을 최적화하는 방법을 얼마나 잘 이해하고 있는지를 평가하려는 의도입니다. Cache-Control, ETag, Expires와 같은 캐싱 관련 헤더의 작동 원리를 알고, 캐싱을 적절히 설정하여 성능을 개선하는 능력과 캐싱 문제를 해결하는 방법을 설명할 수 있는지 확인합니다.

---

### 모범 답안

**1. HTTP 캐싱 관련 헤더의 역할**

1. **Cache-Control**: 캐시 동작을 제어하는 가장 중요한 헤더로, 리소스가 캐싱될 수 있는지, 얼마나 오래 캐싱될지, 또는 특정 조건에서만 캐싱할지 설정할 수 있습니다.
   - `max-age`: 리소스가 캐시될 수 있는 시간을 초 단위로 지정.
   - `no-cache`: 캐시된 리소스를 사용하기 전에 서버에 유효성을 확인하도록 지시.
   - `no-store`: 리소스가 캐시에 저장되지 않도록 함.
   - `public` / `private`: 리소스가 모든 사용자에게 캐시될지(`public`) 또는 특정 사용자에게만 캐시될지(`private`) 설정.
2. **ETag**: 리소스의 고유한 식별자를 제공하여, 클라이언트가 서버에 요청을 보낼 때 해당 리소스가 변경되었는지 확인할 수 있습니다. 변경되지 않았다면 서버는 304 Not Modified 상태 코드를 반환해 불필요한 데이터 전송을 방지합니다.
3. **Expires**: 특정 시간까지 리소스를 캐싱할 수 있는 만료 날짜를 지정합니다. `Cache-Control`의 `max-age` 옵션이 우선 적용되며, `Expires`는 오래된 브라우저 호환성을 위한 옵션으로 사용됩니다.

**2. 브라우저 캐싱을 활용한 성능 최적화**

- **정적 자원 캐싱**: 자주 변경되지 않는 CSS, JS, 이미지 같은 정적 리소스에 대해 `Cache-Control: max-age`를 적절히 설정하여 브라우저가 일정 기간 동안 서버에 재요청하지 않도록 함으로써 성능을 개선할 수 있습니다.
- **ETag와 Last-Modified를 활용한 조건부 요청**: 서버에 리소스를 다시 요청할 때, 리소스가 변경되지 않았으면 전체 데이터를 다시 받지 않도록 하여 네트워크 트래픽을 절감하고 성능을 최적화할 수 있습니다.
- **프리페칭(Prefetching)과 프리로딩(Preloading)**: 사용자가 접근할 가능성이 높은 리소스를 미리 캐시에 저장해 빠르게 로드되도록 할 수 있습니다.

**3. 캐싱 설정 시 발생할 수 있는 문제와 해결 방법**

- **Stale 데이터 문제**: 캐싱된 데이터가 오래되어 최신 상태가 아닐 수 있습니다. 이를 해결하기 위해 `Cache-Control`의 `no-cache`나 `must-revalidate` 옵션을 사용해 유효성을 자주 확인하거나, 자주 갱신되는 리소스에 대해 `ETag`나 `Last-Modified`와 같은 조건부 요청을 설정할 수 있습니다.
- **캐시 무효화 문제**: 리소스가 업데이트되었을 때, 캐싱된 오래된 리소스를 브라우저가 계속 사용할 수 있습니다. 이를 방지하기 위해 파일 이름에 해시를 추가하거나, 버전을 관리하여 캐시를 무효화할 수 있습니다.
- **과도한 캐싱**: 리소스를 과도하게 캐싱하면 메모리 낭비나 불필요한 데이터 유지 문제가 발생할 수 있습니다. 따라서 필요한 리소스에만 적절하게 캐싱을 설정하는 것이 중요합니다.

---

캐싱은 웹 성능 최적화에서 중요한 역할을 담당합니다. 브라우저 캐싱을 효과적으로 활용하면 서버 요청을 줄이고, 불필요한 네트워크 트래픽을 방지하여 사용자에게 더 빠른 응답을 제공할 수 있습니다. 이를 위해 HTTP 헤더에서 제공하는 캐싱 관련 기능을 적절하게 설정하는 것이 중요합니다.

### 1. Cache-Control로 캐싱을 제어하라

`Cache-Control`은 리소스의 캐싱 가능 여부와 지속 시간을 설정하는 강력한 헤더입니다. `max-age` 옵션을 통해 리소스가 브라우저에 얼마나 오랫동안 캐시될지를 초 단위로 설정할 수 있습니다.

예를 들어, 자주 변하지 않는 이미지나 CSS 파일에는 긴 `max-age` 값을 설정해 브라우저가 매번 서버에 요청하지 않도록 하고, 이로 인해 페이지 로딩 속도가 크게 향상됩니다.

```
Cache-Control: public, max-age=31536000

```

### 2. ETag로 조건부 요청을 설정하라

`ETag`는 리소스의 고유한 버전을 나타내는 식별자입니다. 브라우저는 이 식별자를 통해 서버에 "리소스가 변경되었는지"를 확인하고, 변경되지 않았다면 전체 파일을 다시 다운로드하지 않습니다. 이를 통해 불필요한 데이터 전송을 줄일 수 있습니다.

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"

```

### 3. 캐시 무효화를 고려하라

자주 업데이트되는 리소스에 대해선 캐시된 오래된 파일이 계속 사용되는 문제를 피하기 위해 캐시 무효화 전략이 필요합니다. 파일 이름에 해시를 추가하거나, 버전 관리 방식을 도입해 캐시 무효화를 효율적으로 처리할 수 있습니다.

```
style.css?v=1.2.3

```

### 4. 발생할 수 있는 문제와 해결 방법

캐싱을 통해 성능을 향상할 수 있지만, 캐싱 설정이 잘못되면 오래된 데이터를 계속 사용할 수 있는 문제가 발생할 수 있습니다. 이 문제를 해결하기 위해서는 자주 업데이트되는 리소스에는 `no-cache` 옵션을 사용하거나, 조건부 요청을 통해 유효성을 확인하는 방식이 필요합니다.
