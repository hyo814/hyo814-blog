---
title: Debouncing과 Throttling: 프론트엔드 성능 최적화 기법
date: '2024-09-10'
tags: [Debouncing, Throttling]
draft: false
summary: 'Debouncing과 Throttling'
---

# Debouncing과 Throttling: 프론트엔드 성능 최적화 기법

Debouncing과 Throttling의 차이점에 대해 설명하고, 각 기법이 적절한 상황을 예시를 들어 설명해 주세요. 또한, 실제 프로젝트에서 이 두 기법 중 하나를 사용한 경험이 있다면 말씀해주세요.

​

질문의도 입니다!

​

Debouncing과 Throttling 같은 성능 최적화 기법을 이해하고, 이 두 기법의 차이점을 알고 있는지 평가하려는 의도입니다. 또한, 실제로 이벤트 핸들링에서 불필요한 호출을 줄이고 성능을 최적화하기 위해 이러한 기법을 실무에서 어떻게 적용했는지를 통해 문제 해결 능력과 성능 최적화 경험을 확인하려는 목적이 있습니다.

---

### 모범답안

**Debouncing과 Throttling의 차이점**

1. **Debouncing**

   Debouncing은 특정 이벤트가 연속해서 발생할 때 마지막 이벤트가 트리거된 후 일정 시간 동안 추가 이벤트가 발생하지 않을 때만 함수를 실행하는 기법입니다. 즉, 사용자가 여러 번 이벤트를 발생시켜도 마지막 이벤트가 발생한 후 잠시 대기하고, 그때만 함수가 호출됩니다.

   **사용 예시:** 사용자가 입력하는 검색어에 따라 실시간으로 자동완성을 보여주는 기능에서 사용됩니다. 사용자가 입력을 완료하기 전에 API 호출이 여러 번 발생하는 것을 막기 위해, 마지막 입력 후 일정 시간 동안 추가 입력이 없을 때에만 서버로 요청을 보냅니다.

   ```jsx
   function debounce(fn, delay) {
     let timer
     return function (...args) {
       if (timer) clearTimeout(timer)
       timer = setTimeout(() => fn(...args), delay)
     }
   }

   const onInputChange = debounce((e) => {
     // 서버로 API 요청
     console.log('API 호출:', e.target.value)
   }, 300)
   ```

2. **Throttling**

   Throttling은 일정 시간 간격으로 함수가 실행되도록 하는 기법입니다. 연속된 이벤트 발생 중에도 일정한 주기로만 함수가 실행되므로, 초과 이벤트는 무시됩니다.

   **사용 예시:** 사용자가 스크롤을 할 때 매번 이벤트가 발생하는 대신, 스크롤 상태를 1초에 한 번씩만 업데이트하여 스크롤 이벤트 처리를 최적화할 수 있습니다.

   ```jsx
   function throttle(fn, limit) {
     let lastFunc
     let lastRan
     return function (...args) {
       if (!lastRan) {
         fn(...args)
         lastRan = Date.now()
       } else {
         clearTimeout(lastFunc)
         lastFunc = setTimeout(
           () => {
             if (Date.now() - lastRan >= limit) {
               fn(...args)
               lastRan = Date.now()
             }
           },
           limit - (Date.now() - lastRan)
         )
       }
     }
   }

   const onScroll = throttle(() => {
     console.log('스크롤 이벤트 처리')
   }, 1000)
   ```

**Debouncing과 Throttling의 차이점 요약**

- **Debouncing**은 이벤트가 연속적으로 발생해도 마지막 이벤트 이후 정해진 시간 동안 이벤트가 발생하지 않을 때 함수가 실행됩니다.
- **Throttling**은 이벤트가 연속적으로 발생할 때 정해진 시간 간격으로 함수가 실행됩니다.

**프로젝트 적용 경험**

저는 이전에 사용자가 입력할 때 API를 호출하는 검색 기능에서 **Debouncing**을 적용한 경험이 있습니다. 사용자가 빠르게 입력할 때마다 API 요청이 발생하면 서버 부하가 증가하기 때문에, 입력이 끝난 후 일정 시간이 지나면 요청을 보내도록 하여 성능을 최적화하였습니다. 이로 인해 API 호출 수가 크게 줄어들었고, 사용자는 보다 빠른 반응성을 느낄 수 있었습니다.

---

프론트엔드 개발에서는 사용자 경험을 향상시키고 성능을 최적화하기 위한 다양한 기법들이 있습니다. 그 중에서 **Debouncing**과 **Throttling**은 이벤트 핸들링에서 중요한 역할을 합니다. 이번 글에서는 이 두 가지 기법의 차이점과 실무에서 적용할 수 있는 상황을 설명해 보겠습니다.

## 1. Debouncing이란?

**Debouncing**은 연속적인 이벤트 발생을 제어하여 마지막 이벤트가 발생한 후 일정 시간 동안 추가 이벤트가 발생하지 않을 때만 함수를 실행하는 방법입니다.

### 사용 예시: 검색 자동완성

사용자가 검색어를 입력할 때마다 서버로 API 요청을 보내는 대신, 입력이 끝난 후 일정 시간 동안 추가 입력이 없을 때만 API 요청을 보냅니다. 이 방법은 서버 부하를 줄이고 사용자가 원하는 결과를 빠르게 얻을 수 있도록 돕습니다.

```jsx
function debounce(fn, delay) {
  let timer
  return function (...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => fn(...args), delay)
  }
}

const onInputChange = debounce((e) => {
  console.log('API 호출:', e.target.value)
}, 300)
```

## 2. Throttling이란?

**Throttling**은 이벤트가 연속적으로 발생해도 일정한 시간 간격으로만 함수가 실행되도록 제한하는 방법입니다. 이 기법은 많은 이벤트를 제어할 때 유용합니다.

### 사용 예시: 스크롤 이벤트 처리

스크롤 이벤트는 사용자가 페이지를 스크롤할 때마다 발생하는데, 이를 매번 처리하면 성능에 큰 영향을 미칠 수 있습니다. **Throttling**을 적용하여 스크롤 상태를 1초에 한 번씩만 업데이트하도록 제한할 수 있습니다.

```jsx
function throttle(fn, limit) {
  let lastFunc
  let lastRan
  return function (...args) {
    if (!lastRan) {
      fn(...args)
      lastRan = Date.now()
    } else {
      clearTimeout(lastFunc)
      lastFunc = setTimeout(
        () => {
          if (Date.now() - lastRan >= limit) {
            fn(...args)
            lastRan = Date.now()
          }
        },
        limit - (Date.now() - lastRan)
      )
    }
  }
}

const onScroll = throttle(() => {
  console.log('스크롤 이벤트 처리')
}, 1000)
```

## 3. 차이점 정리

| 기법           | 설명                                                       | 사용 예시            |
| -------------- | ---------------------------------------------------------- | -------------------- |
| **Debouncing** | 마지막 이벤트 후 일정 시간 동안 추가 이벤트가 없을 때 실행 | 검색 자동완성        |
| **Throttling** | 일정 시간 간격으로 이벤트를 처리                           | 스크롤 이벤트 최적화 |
