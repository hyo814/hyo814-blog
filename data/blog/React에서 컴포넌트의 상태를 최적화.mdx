---
title: RReact에서 컴포넌트의 상태를 최적화하기 위해 불변성을 유지하는 것이 중요한 이유
date: '2024-01-12'
tags: [불변성]
draft: false
summary: '불변성'
---

# React에서 컴포넌트의 상태를 최적화하기 위해 불변성을 유지하는 것이 중요한 이유

React에서 컴포넌트의 상태를 최적화하기 위해 불변성을 유지하는 것이 중요한 이유를 설명하고, 불변성을 효율적으로 유지하기 위한 도구나 기법들(immer, Object.assign, 스프레드 연산자 등)에 대해 설명해주세요.

​

질문의도 입니다!

​

불변성을 깨뜨릴 때 발생할 수 있는 리렌더링 문제나 디버깅 어려움을 인식하고, 이를 방지하기 위한 최적화 전략을 설명할 수 있는지를 확인합니다.

---

### 모범 답안

React에서 **불변성**을 유지하는 것은 컴포넌트 상태 관리의 중요한 부분입니다. 그 이유는 React가 **Virtual DOM**을 활용하여 UI를 효율적으로 업데이트하기 때문입니다. React는 컴포넌트 상태(state)가 변경되었을 때, 그 변경된 상태와 이전 상태를 비교하여 필요한 부분만 다시 렌더링합니다. 이 과정에서 상태가 **불변**하지 않다면, React는 상태가 변경되었는지 감지하기 어렵게 되고, 불필요한 리렌더링이 발생하거나 디버깅이 복잡해질 수 있습니다.

불변성을 깨뜨리면 **리렌더링 문제**와 **예측 불가능한 버그**가 발생할 수 있습니다. 예를 들어, 참조형 데이터(객체나 배열)의 값을 직접 변경하면, React는 그 변화를 인지하지 못할 수 있으며, 이로 인해 **상태 변경에 따른 UI 업데이트**가 제대로 이루어지지 않을 수 있습니다. 따라서 불변성을 유지하는 것이 중요하며, 상태를 변경할 때는 항상 새로운 객체를 반환하는 방식으로 처리해야 합니다.

### 불변성을 효율적으로 유지하는 도구와 기법들

1.  **스프레드 연산자** (`...`):
    스프레드 연산자는 기존 객체나 배열을 복사한 후, 그 복사본에 새로운 값을 추가하거나 변경하는 방식으로 불변성을 유지할 수 있습니다.

        ```jsx
        // 객체의 불변성을 유지하면서 업데이트
        const newState = { ...oldState, key: newValue };

        // 배열의 불변성을 유지하면서 업데이트
        const newArray = [...oldArray, newElement];

        ```

2.  **Object.assign**:
    `Object.assign`은 객체의 속성을 복사하여 새로운 객체를 생성하는 방식입니다. 하지만 깊은 복사가 아닌 얕은 복사이기 때문에 다차원 객체를 다룰 때는 주의가 필요합니다.

        ```jsx
        const newState = Object.assign({}, oldState, { key: newValue });

        ```

3.  **Immer**:
    `immer`는 복잡한 상태 변경 로직을 단순화하고 불변성을 자동으로 유지해 주는 도구입니다. Immer를 사용하면, 기존 상태를 직접 변경하는 것처럼 코드를 작성해도 내부적으로 불변성을 유지한 채 새로운 상태를 반환합니다.

        ```jsx
        import produce from 'immer';

        const newState = produce(oldState, draft => {
            draft.key = newValue;
        });

        ```

        Immer는 특히 복잡한 상태 구조를 가진 경우에 매우 유용합니다.

### 최적화 전략

- **불필요한 리렌더링 방지**: 불변성을 유지하여 상태 변화가 있을 때만 컴포넌트가 리렌더링되도록 보장할 수 있습니다. 이를 통해 성능을 최적화할 수 있습니다.
- **React.memo**를 사용하여 상태가 변경되지 않는 경우 컴포넌트의 재렌더링을 방지할 수 있습니다.
- **useCallback**과 **useMemo** 같은 React 훅을 활용하여 함수나 계산된 값을 캐싱해 불필요한 계산을 줄일 수 있습니다.

**결론적으로**, 불변성을 유지함으로써 React의 리렌더링 메커니즘과 최적화 전략을 최대한 효율적으로 활용할 수 있으며, 이를 위해 다양한 도구와 기법을 적절하게 사용하는 것이 중요합니다.

---

React에서 불변성 유지의 중요성과 상태 최적화 전략

React는 컴포넌트 기반의 UI 라이브러리로, 상태(state) 관리가 매우 중요한 역할을 합니다. 특히 **불변성**(Immutability)을 유지하는 것이 컴포넌트 상태 관리에서 중요한 이유는 **Virtual DOM**을 통한 효율적인 업데이트와 성능 최적화 때문입니다.

### 1. 불변성 유지의 중요성

React의 **Virtual DOM**은 실제 DOM에 비해 빠르게 변화하는 UI를 효율적으로 관리할 수 있도록 도와줍니다. 이 과정에서 React는 상태가 변경되었을 때, 이전 상태와 비교하여 변경된 부분만 다시 렌더링합니다. 하지만 여기서 중요한 점은 **상태가 불변해야** 상태 변경을 감지할 수 있다는 것입니다.

### 예시: 불변성이 깨질 경우 발생할 수 있는 문제

```jsx
const obj = { a: 1, b: 2 }
const newObj = obj
newObj.a = 3

console.log(obj.a) // 3
```

위 예시에서 `newObj`와 `obj`는 같은 참조를 공유하기 때문에, `newObj`를 변경하면 `obj`도 함께 변경됩니다. React에서는 이러한 참조형 데이터의 직접적인 변경이 문제가 될 수 있습니다. 불변성을 깨뜨리면 **리렌더링 문제**나 **디버깅의 어려움**을 겪게 될 가능성이 높습니다.

따라서 상태를 관리할 때는 **기존 상태를 직접 수정하지 않고, 새로운 객체를 반환**하는 방식으로 불변성을 유지해야 합니다. 이렇게 하면 React는 상태가 실제로 변경되었는지 쉽게 판단할 수 있고, 필요한 경우에만 컴포넌트를 리렌더링할 수 있습니다.

### 2. 불변성을 유지하는 방법들

React에서 불변성을 유지하기 위해 다양한 도구와 기법들이 활용됩니다. 아래에서 몇 가지 대표적인 방법을 소개하겠습니다.

### 2.1. 스프레드 연산자 (`...`)

스프레드 연산자는 객체나 배열을 복사한 후, 그 복사본을 기반으로 상태를 업데이트할 수 있는 간단한 방법입니다. 이 방식은 불변성을 쉽게 유지하면서 상태를 업데이트할 수 있습니다.

```jsx
// 객체의 불변성을 유지하면서 업데이트
const newState = { ...oldState, key: newValue }

// 배열의 불변성을 유지하면서 업데이트
const newArray = [...oldArray, newElement]
```

### 2.2. `Object.assign`

`Object.assign` 메서드는 객체의 속성을 복사하여 새로운 객체를 생성하는 방법입니다. 하지만 깊은 복사가 아닌 **얕은 복사**이므로, 중첩된 객체를 다룰 때는 주의가 필요합니다.

```jsx
const newState = Object.assign({}, oldState, { key: newValue })
```

### 2.3. Immer

`immer`는 상태 변경을 단순화하고 불변성을 자동으로 유지해 주는 유용한 도구입니다. 기존 상태를 직접 수정하는 것처럼 보이지만, 실제로는 immer가 내부적으로 불변성을 유지한 새로운 상태를 반환합니다.

```jsx
import produce from 'immer'

const newState = produce(oldState, (draft) => {
  draft.key = newValue
})
```

**Immer**는 특히 상태 구조가 복잡한 경우에 매우 유용하며, 코드 가독성을 크게 향상시켜 줍니다.

### 3. 최적화 전략

불변성을 유지하는 것은 단지 코드의 안정성을 높이는 것뿐만 아니라 **성능 최적화**와도 깊은 관련이 있습니다. React에서 상태 변화가 감지될 때마다 컴포넌트가 리렌더링되는데, 불변성을 유지하지 않으면 불필요한 리렌더링이 발생할 수 있습니다.

### 3.1. `React.memo`

`React.memo`는 컴포넌트가 리렌더링될 필요가 없을 때 렌더링을 건너뛰도록 도와줍니다. 불변성이 유지된 상태에서 `React.memo`를 적용하면, 상태가 변하지 않은 경우 렌더링을 최적화할 수 있습니다.

```jsx
const MyComponent = React.memo(function MyComponent({ value }) {
  return <div>{value}</div>
})
```

### 3.2. `useCallback`과 `useMemo`

React의 `useCallback`과 `useMemo` 훅은 함수나 계산된 값을 **캐싱**하여 불필요한 재계산이나 재렌더링을 방지하는 데 유용합니다. 이를 통해 상태 변화가 없는 경우에도 불필요한 작업을 줄일 수 있습니다.

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b])
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b])
```

### 4. 불변성을 유지하면 얻는 이점

- **예측 가능한 상태 관리**: 불변성을 유지하면 상태의 변화가 명확하게 드러나므로 디버깅이 쉬워집니다.
- **리렌더링 최적화**: React는 상태가 변경되었을 때만 렌더링하므로, 불변성을 유지하면 불필요한 리렌더링을 방지할 수 있습니다.
- **코드 가독성 향상**: `immer` 같은 도구를 사용하면 상태 변경 로직이 간결해지고, 코드의 가독성도 크게 개선됩니다.

---

### 마무리

React에서 **불변성을 유지하는 것**은 단순한 코드 작성 습관이 아니라 **성능 최적화**와 **예측 가능한 상태 관리**를 위한 중요한 전략입니다. 다양한 도구와 기법을 적절히 활용하여 불변성을 유지하면서 상태를 관리하면, 더욱 효율적이고 안정적인 React 애플리케이션을 만들 수 있습니다. React의 **Virtual DOM**과 **불변성**의 개념을 잘 이해하고 이를 실천하는 것이 프론트엔드 개발의 중요한 첫걸음입니다.
